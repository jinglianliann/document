1.C++中类与结构的唯一区别是：类（class）定义中默认情况下的成员是private的，而结构（struct）定义中默认情况下的成员是public的。
2. ::叫作用域区分符，指明一个函数属于哪个类或一个数据属于哪个类。::可以不跟类名，表示全局数据或全局函数（即非成员函数）。
3.类名加载成员函数名之前而不是加在函数的返回类型前。
	错误：Tdate::void Set(int m , int d , int y) {}
	正确： void Tdate::Set(int m , int d , int y) {}
4.一个类对象所占据的内存空间由它的数据成员所占据的空间总和所决定。类的成员函数不占据对象的内存空间。
5.类的成员函数可以访问该类的private成员。
6.类作用域是指类定义和相应的成员函数定义范围。在该范围内，一个类的成员函数对同一类的数据成员具有无限制的访问权。
7.#include <filename.h> 和#include “filename.h” 有什么区别？
	对于#include <filename.h> ，编译器从标准库路径开始搜索filename.h
	对于#include “filename.h”，编译器从用户的工作路径开始搜索filename.h
8.
	int a = 1 , b = 0;   // #define MAX(A,B) A>B?A:B;
	MAX(a++ , b);    //a被增值2次  
	MAX(a++ , b + 10); //a被增值1次 
	
9.类定义是不分配空间和初始化的。类是一个抽象的概念，并不是一个实体，并不含有属性值，而只有对象才占有一定的空间，含有明确的属性值。
10. 按成员在类定义中的声明顺序进行构造，而不是按构造函数说明中冒号后面的顺序。
	运行如下代码：
	复制代码
	class A
	{
	public:
	    A(int j):age(j) , num(age + 1)
	protected:
	    int num;
	    int age;
	};

	void mian()
	{
	    A sa(15);
	}
	复制代码
	代码运行结果：num=“随机值 ”， age= 15
	由于按成员在类定义中的声明顺序进行构造，而不是按构造函数说明中冒号后面的顺序，所以num成员被赋的是一个随机值，并不是想赋的16，因为这个时候，成员age还没有被赋值，age的内存空间中是一个随机值。
	
11.如果 const 出现在 * 左边，则指针指向的内容为常量；如果 const 出现在 * 右边，则指针自身为常量；如果 const 出现在 * 两边，则两者都为常量。
	const 的意思可以理解为"只读"。  
	
12.C++一维数组和指针的关系总结
	对于数组int a[10]; a表示数组的第一个元素的地址，即&a[0];
	如果使指针p，指向数组的首元素，可以进行操作：int * p=a; 或者int *p=&a[0];
	那么p++，是指向数组中的先一个元素，即a[1];
	　　此时*p则是a[1]中所放的值。
	　　此时，a[i]=p[i]=*(a+i)=*(p+i)
	关于*p++，由于++和*的优先级相同，结合方向是自右而左，因此它等价于*(p++)。作用是：先得到p指向的变量的值（即*p），然后再使指向p的值加1.
	*p++等价于*(p++);而*(++p)表示先使p+1,再取*p。	也要注意静态二维数组空间的连续性，如果分别new出来的一位数组则不连续。
	
13.在VC中，sizeof有着许多的用法，而且很容易引起一些错误。下面根据sizeof后面的参数对sizeof的用法做个总结。
	A.参数为数据类型或者为一般变量：
	例如sizeof(int),sizeof(long)等等。
	这种情况要注意的是不同系统系统或者不同编译器得到的结果可能是不同的。
	例如int类型在16位系统中占2个字节，在32位系统中占4个字节。
	B.参数为数组或指针：
	int a[50]; //sizeof(a)=4*50=200;求数组所占的空间大小
	int *a=new int[50];// sizeof(a)=4; a为一个指针，sizeof(a)是求指针的大小,在32位系统中，当然是占4个字节。
	C.参数为结构或类：
	Sizeof应用在类和结构的处理情况是相同的，需要考虑字节对齐(参加另一篇文章：http://www.cnblogs.com/heyonggang/archive/2012/12/11/2812304.html)。另外有几点需要注意：
	第一、结构或者类中的静态成员不对结构或者类的大小产生影响，因为静态变量的存储位置与结构或者类的实例地址无关。
	第二、没有成员变量的结构或类(非虚)的大小为1，因为必须保证结构或类的每一个实例在内存中都有唯一的地址。
	第三、包含虚函数的类或者虚继承的类，需要算上虚表指针的占的4个字节。
	下面举例说明：
	Class Test{int a;static double c};//sizeof(Test)=4
	Test *s;//sizeof(s)=4,s为一个指针。
	Class test1{ };//sizeof(test1)=1;
	Class test2{ virtual void print(){}};//sizeof(test2)=4;	
	32位编译器：
		char ：1个字节
		char*（即指针变量）: 4个字节（32位的寻址空间是2^32, 即32个bit，也就是4个字节。同理64位编译器）
		short int : 2个字节
		int：4个字节
		unsigned int : 4个字节
		float:4个字节
		double:8个字节
		long:4个字节
		long long:8个字节
		unsigned long:4个字节

	64位编译器：
		char ：1个字节
		char*(即指针变量): 8个字节
		short int : 2个字节
		int：4个字节
		unsigned int : 4个字节
		float:4个字节
		double:8个字节
		long:8个字节
		long long:8个字节
		unsigned long:8个字节

14.运算符new分配堆内存，如果成功，则返回指向该内存的空间，如果失败，则返回NULL。所以每次使用运算符new动态分配内存时，都应测试new的返回指针值，以防分配失败。
	注意反复new和free堆里面的内存空间，会产生内存碎片影响系统性能，这种情况应该考虑内存池。

15.如果你的类需要析构函数来析构资源，则它也需要一个拷贝构造函数（如果成员变量包含指针）。
	由于C++提供的默认拷贝构造函数只是对对象进行浅拷贝复制。如果对象的数据成员包括指向堆空间的指针，就不能使用这种拷贝方式，此时必须自定义拷贝构造函数，为创建的对象分配堆空间。
	
16.类成员函数的重载、覆盖和隐藏区别？
    答案：
    a.成员函数被重载的特征：
    （1）相同的范围（在同一个类中）；（2）函数名字相同；（3）参数不同；（4）virtual 关键字可有可无。
    b.覆盖是指派生类函数覆盖基类函数，特征是：
    （1）不同的范围（分别位于派生类与基类）；（2）函数名字相同；（3）参数相同；（4）基类函数必须有virtual 关键字。
    c.“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
    （1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。
    （2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）
17.《C++程序设计教程》P352
	在例子中并没有声明派生类GraduateStudent的构造函数，根据类的实现机制，派生类对象创建时，将执行其默认的构造函数。
	该默认构造函数会先调用基类的默认构造函数，而基类没有默认构造函数，但正好匹配默认参数的构造函数。

18.在运行时，能根据其类型确认调用哪个函数的能力，称为多态性，或称迟后联编，或滞后联编。编译时就能确定哪个重载函数被调用的，称为先期联编。
	多态性可可以简单的概括为“一个借口，多种方法”，在程序运行的过程中才决定调用的函数。
	虚函数就是允许被其子类重新定义的成员函数。而子类重新定义父类虚函数的做法，称为“覆盖”或“重写”。
	覆盖是指子类重新定义父类的虚函数的做法。
	重载是指允许存在多个同名函数，而这些函数的参数表不同。
	为了指明某个成员函数具有多态性，用关键字virtual来标志其为虚函数。
	如果虚函数在基类与子类中出现的仅仅是名字的相同，而参数类型不同，或返回类型不同，即使写上了virtual关键字，则也不进行迟后联编。
	
19.一个类中将所有的成员函数都尽可能地设置为虚函数总是有益的。它除了会增加一些资源开销，没有其它坏处。
	设置虚函数，需注意下列事项：
	只有类的成员函数才能说明为虚函数。这是因为虚函数仅适用于有继承关系的类对象，所以普通函数不能说明为虚函数。
	静态成员函数不能是虚函数，因为静态成员函数不受限于某个对象。
	内联函数不能是虚函数，因为内联函数是不能在运行中动态确定其位置的。即使虚函数在类的内部定义，编译时，仍将其看作非内联的。
	构造函数不能是虚函数，因为构造时，对象还是一片未定型的空间。只有在构造完成后，对象才能成为一个类的名副其实的实例。
	析构函数可以是虚函数，而且通常声明为虚函数。

20. stl
	向量(vector)   连续存储的元素<vector>
	列表(list)     由节点组成的双向链表，每个结点包含着一个元素<list>
	双队列(deque)  连续存储的指向不同元素的指针所组成的数组<deque>
	集合(set)      由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种作用于元素对的谓词排列，没有两个不同的元素能够拥有相同的次序 <set>
	多重集合(multiset) 允许存在两个次序相等的元素的集合 <set>  multiset，与set不同之处就是它允许有重复的值,key 是不用的，但是key是set自己管理的。
	栈(stack)          后进先出的值的排列 <stack>
	队列(queue)        先进先出的执的排列 <queue>
	优先队列(priority_queue) 元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列 <queue>
	映射(map)                由{键，值}对组成的集合，也是以红黑平衡二叉树实现的，以某种作用于键对上的谓词排列 <map>
	多重映射(multimap)       允许键对有相等的次序的映射 <map>
	multiset与set的不同之处就是key可以重复，以及erase（key）的时候会删除multiset里面所有的key并且返回删除的个数。
	
	<utility>是一个很小的头文件，它包括了贯穿使用在STL中的几个模板的声明，
	<iterator>中提供了迭代器使用的许多方法，而对于<memory>的描述则十分的困难，它以不同寻常的方式为容器中的元素分配存储空间，同时也为某些算法执行期间产生的临时对象提供机制,
	<memory>中的主要部分是模板类allocator，它负责产生所有容器中的默认分配器
	
	vector应该是从堆上分配内存，所有大小与元素个数无关
	sizeof(vector)取决于vector类的具体实现，STL是个完全开放的东西，谁都可以来实现vector类。
	通过查看STL源码可以看到vector有四个成员变量?
	_A ? allocator;?
	iterator ? _First, ? _Last, ? _End;?
	每个指针是4个字节，因此16字节。20字节的是不是添加了什么指针呢？

	deque和vector一样,采用线性表，与vector唯一不同的是，
	deque采用的分块的线性存储结构，每块大小一般为512字节，称为一个deque块，
	所有的deque块使用一个Map块进行管理，每个map数据项记录各个deque块的首地址，这样以来，
	deque块在头部和尾部都可已插入和删除元素，而不需要移动其它元素。使用push_back()方法在尾部插入元素，使用push_front()方法在首部插入元素，
	使用insert()方法在中间插入元素。一般来说，当考虑容器元素的内存分配策略和操作的性能时，deque相对vectore更有优势。
	
	erase
	list与vector 
    list与vector中的erase用法相同，它们的 erase 函数会返回指向下一个元素的迭代器，因此在遍历时，只需要 it = c.erase(it); 即可。
  map与set
    map与set中的erase用法相同，它们的 erase 函数返回值是 void，调用 erase 之后，当前迭代器会失效，无法再用于获取下一个迭代器。因此需要 erase 之前就获取指向下一个元素的迭代器。

  函数调用规则
	__cdecl调用规则就是C调用规则。按从右至左的顺序压参数入栈，由调用者把参数弹出栈。
		切记：对于传送参数的内存栈是由调用者来维护的。返回值在EAX中因此，对于象printf这样变参数的函数必须用这种规则。
		编译器在编译的时候对这种调用规则的函数生成修饰名的饿时候，仅在输出函数名前加上一个下划线前缀，格式为_functionname。
	__stdcall也是按从右至左的顺序压参数入栈，但是它是由被调用者把参数弹出栈。
		_stdcall是Pascal程序的缺省调用方式，通常用于Win32 Api中，切记：函数自己在退出时清空堆栈，返回值在EAX中。　　
		__stdcall调用约定在输出函数名前加上一个下划线前缀，后面加上一个“@”符号和其参数的字节数，格式为_functionname@number。
	__fastcall调用的主要特点就是快，因为它是通过寄存器来传送参数的
		（实际上，它用ECX和EDX传送前两个双字（DWORD）或更小的参数，剩下的参数仍旧自右向左压栈传送，被调用的函数在返回前清理传送参数的内存栈）
		__fastcall调用约定在输出函数名前加上一个“@”符号，后面也是一个“@”符号和其参数的字节数，格式为@functionname@number。	
    
  static
  
  1.先来介绍它的第一条也是最重要的一条：隐藏
  2.static的第二个作用是保持变量内容的持久 （可以视为隐藏的全局变量）
  3.static的第三个作用是默认初始化为0
  4.static的第四个作用：C++中的类成员声明static
  在类中声明static变量或者函数时，初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员，这样就出现以下作用：
	(1)类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致 了它仅能访问类的静态数据和静态成员函数。//不能访问非静态数据和成员。
	(2)不能将静态成员函数定义为虚函数。
	(3)由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊 ，变量地址是指向其数据类型的指针 ，函数地址类型是一个“nonmember函数指针”。
	(4)由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就 产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C++和C-based X W indow系统结合，同时也成功的应用于线程函数身上。 （这条没遇见过）  
	(5)static并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问 时间，节省了子类的内存空间。      
	(6)静态数据成员在<定义或说明>时前面加关键字static。      
	(7)静态数据成员是静态存储的，所以必须对它进行初始化。 （程序员手动初始化，否则编译时一般不会报错，但是在Link时会报错误） 
	(8)静态成员初始化与一般数据成员初始化不同:
	初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；
	初始化时不加该成员的访问权限控制符private，public等；        
	初始化时使用作用域运算符来标明它所属类；
	           所以我们得出静态数据成员初始化的格式：
	<数据类型><类名>::<静态数据成员名>=<值>

  (9)为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。
    
   虚表
	    虚函数的实现是使用虚表
	    继承至虚函数 子类覆盖虚函数，其实是在续表内的覆盖
	    普通同名函数，其实是对子类函数，进行重命名。
	    多继承的虚函数，类定义了相同的虚函数，则全部覆盖。
	 
	struct &union
	 		struct和union都是由多个不同的数据类型成员组成, 但在任何同一时刻, union中只存放了一个被选中的成员; 而struct的所有成员都存在。
	 		在struct中，各成员都占有自己的内存空间，它们是同时存在的,一个struct变量的总长度等于所有成员长度之和，
	 		遵从字节对其原则; 在Union中，所有成员不能同时占用它的内存空间，它们不能同时存在 , Union变量的长度等于最长的成员的长度。
	 
	    对于union的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了,所以，共同体变量中起作用的成员是最后一次存放的成员; 
	    而对于struct的不同成员赋值是互不影响的。
	    
	    union 很想 enum 只不过enum的成员都是整数类型。 
	    
	  有了malloc/free为什么还要new/delete？
	　　malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。
	　　对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。
			由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。
			因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。
			
			
	内存管理：
		
		堆 heap ：
			由new分配的内存块，其释放编译器不去管，由我们程序自己控制（一个new对应一个delete）。如果程序员没有释放掉，在程序结束时OS会自动回收。涉及的问题：“缓冲区溢出”、“内存泄露”

		栈 stack ：
			是那些编译器在需要时分配，在不需要时自动清除的存储区。存放局部变量、函数参数。
			存放在栈中的数据只在当前函数及下一层函数中有效，一旦函数返回了，这些数据也就自动释放了。

		全局/静态存储区 （.bss段和.data段） ：
			全局和静态变量被分配到同一块内存中。在C语言中，未初始化的放在.bss段中，初始化的放在.data段中；在C++里则不区分了。

		常量存储区 （.rodata段） ：
			存放常量，不允许修改（通过非正当手段也可以修改）

		代码区 （.text段）：
			存放代码（如函数），不允许修改（类似常量存储区），但可以执行（不同于常量存储区）
					
		根据c/c++对象生命周期不同，c/c++的内存模型有三种不同的内存区域，即
			自由存储区：局部非静态变量的存储区域，即平常所说的栈
			动态区：用operator new ，malloc分配的内存，即平常所说的堆
			静态区：全局变量 静态变量 字符串常量存在位置

	
	c11
		auto
			C++11中引入auto第一种作用是为了自动类型推导
			auto的自动类型推导，用于从初始化表达式中推断出变量的数据类型。通过auto的自动类型推导，可以大大简化我们的编程工作
			auto实际上实在编译时对变量进行了类型推导，所以不会对程序的运行效率造成不良影响
			另外，似乎auto并不会影响编译速度，因为编译时本来也要右侧推导然后判断与左侧是否匹配。	
				auto不光有以上的应用，它在模板中也是大显身手，比如下例这个加工产品的例子中，如果不使用auto就必须声明Product这一模板参数：
				template <typename Product, typename Creator>  
				void processProduct(const Creator& creator) {  
				    Product* val = creator.makeObject();  
				    // do somthing with val  
				}         
				        . 
				如果使用auto，则可以这样写：
				template <typename Creator>  
				void processProduct(const Creator& creator) {  
				    auto val = creator.makeObject();  
				    // do somthing with val  
				}
				
		decltype
			decltype实际上有点像auto的反函数，auto可以让你声明一个变量，而decltype则可以从一个变量或表达式中得到类型，有实例如下：
			int x = 3;  
			decltype(x) y = x;  //提供一种通过变量去定义变量，的机制。
			有人会问，decltype的实用之处在哪里呢，我们接着上边的例子继续说下去，如果上文中的加工产品的例子中我们想把产品作为返回值该怎么办呢？我们可以这样写：		 
			
		nullptr
			nullptr是为了解决原来C++中NULL的二义性问题而引进的一种新的类型，因为NULL实际上代表的是0，
			
		for
			在C++中for循环可以使用类似java的简化的for循环，可以用于遍历数组，容器，string以及由begin和end函数定义的序列（即有Iterator），示例代码如下：
			map<string, int> m{{"a", 1}, {"b", 2}, {"c", 3}};  
			for (auto p : m){  
			    cout<<p.first<<" : "<<p.second<<endl;  
			}
			
		Lambda表达式
			lambda表达式类似Javascript中的闭包，它可以用于创建并定义匿名的函数对象，以简化编程工作。Lambda的语法如下：

			[函数对象参数]（操作符重载函数参数）->返回值类型{函数体}
			vector<int> iv{5, 4, 3, 2, 1};  
			int a = 2, b = 1;  
			for_each(iv.begin(), iv.end(), [b](int &x){cout<<(x + b)<<endl;}); // (1) 
			for_each(iv.begin(), iv.end(), [=](int &x){x *= (a + b);});     // (2) 
			for_each(iv.begin(), iv.end(), [=](int &x)->int{return x * (a + b);});// (3) 
			[]内的参数指的是Lambda表达式可以取得的全局变量。(1)函数中的b就是指函数可以得到在Lambda表达式外的全局变量，如果在[]中传入=的话，即是可以取得所有的外部变量，如（2）和（3）Lambda表达式
			()内的参数是每次调用函数时传入的参数。
			->后加上的是Lambda表达式返回值的类型，如（3）中返回了一个int类型的变量
			
		变长参数的模板
			我们在C++中都用过pair，pair可以使用make_pair构造，构造一个包含两种不同类型的数据的容器。比如，如下代码：
			auto p = make_pair(1, "C++ 11"); 
			由于在C++11中引入了变长参数模板，所以发明了新的数据类型：tuple，tuple是一个N元组，可以传入1个， 2个甚至多个不同类型的数据
			auto t1 = make_tuple(1, 2.0, "C++ 11");  
			auto t2 = make_tuple(1, 2.0, "C++ 11", {1, 0, 2}); 
			这样就避免了从前的pair中嵌套pair的丑陋做法，使得代码更加整洁

			另一个经常见到的例子是Print函数，在C语言中printf可以传入多个参数，在C++11中，我们可以用变长参数模板实现更简洁的Print

			template<typename head, typename... tail>  
			void Print(Head head, typename... tail) {  
			    cout<< head <<endl;  
			    Print(tail...);  
			} 
			Print中可以传入多个不同种类的参数，如下：
			Print(1, 1.0, "C++11"); 
			
		更加优雅的初始化方法
			在引入C++11之前，只有数组能使用初始化列表，其他容器想要使用初始化列表，只能用以下方法：
			int arr[3] = {1, 2, 3}  
			vector<int> v(arr, arr + 3); 
			在C++11中，我们可以使用以下语法来进行替换：
			int arr[3]{1, 2, 3};  
			vector<int> iv{1, 2, 3};  
			map<int, string>{{1, "a"}, {2, "b"}};  
			string str{"Hello World"};
		
		Lambda函数
			C++14的泛型Lambda使编写如下语句成为可能：
			auto lambda = [](auto x, auto y) {return x + y;};
			而另一方面，C++11要求Lambda参数使用具体的类型声明，比如：
			auto lambda = [](int x, int y) {return x + y;};
			此外，新标准中的std::move函数可用于捕获Lambda表达式中的变量，这是通过移动对象而非复制或引用对象实现的：
			std::unique_ptr ptr(new int(10));
			auto lambda = [value = std::move(ptr)] {return *value;};
			
		constexpr
			在C++11中，使用constexpr声明的函数可以在编译时执行，生成一个值，用在需要常量表达式的地方，比如作为初始化模板的整形参数。
			C++11的constexpr函数只能包含一个表达式，C++14放松了这些限制，支持诸如if 和switch等条件语句，支持循环，其中包括基于区间（range）的for 循环。
		
		类型推导
			C++11仅支持Lambda函数的类型推导，C++14对其加以扩展，支持所有函数的返回类型推导：
			auto DeducedReturnTypeFunction();

			因为C++14是强类型语言，有些限制需要考虑：
				如果一个函数的实现中有多个返回语句，这些语句一定要推导出同样的类型。
				返回类型推导可以用在前向声明中，但是在使用它们之前，翻译单元中必须能够得到函数定义。
				返回类型推导可以用在递归函数中，但是递归调用必须以至少一个返回语句作为先导，以便编译器推导出返回类型。
				C++14带来的另一个类型推导方面的改进是decltype(auto)语法，它支持使用与auto同样的机制计算给定表达式的类型。
					auto和 decltype在C++11中就已经出现了，但是它们在推导类型时使用了不同的机制，这可能会产生不同的结果。
					
				C++14中的其他改变包括可以声明变量模板，支持使用0b或0B前缀来声明二进制字面常量。InfoQ已经介绍过C++14中可能破坏C++11程序的其他小型修改。
				主流C++编译器对新语言特性的支持正在有条不紊地开发：Clang“完全实现了当前草案的所有内容”；GCC和Visual Studio也对C++14的新特性提供了一些支持。		     
	 
    		std=c++0x
    		
    多线程
			这是第一次，C++11将包含一种内存模型和对应的多线程库，这意味着你将可以编写符合标准的多线程代码。
			新标准将提供所有的通用线程方法，比如线程、线程局部存储和原子操作。
			它也提供了一系列有趣的特性：futures和promises。futures和promises的主要思想是，你可以编写代码表示，“这个对象，一个future代码还没计算完的结果”，它将可以在后台计算结果。
			当这个值需要的时候，你向future发请求，假如这个值准备好了，那就可以得到它，要不然继续等待。
			
	random_device
		生成随机数，免去了以前需要自行调用srand初始化种子的步骤，因为有时忘了初始化结果导致错误。用法:
		std::random_device
		 rd; 
		int randint =
		rd();
	std::ref和std::cref
		分别对应变量的引用和const引用，主要用于作为c++11函数式编程时传递的参数
	原子变量
		std::atomic<XXX>
		用于多线程资源互斥操作，属c++11重大提升，多线程原子操作简单了许多
		事实上基于c++11实现的无锁队列，让boost::lockfree无锁队列也将成为历史
		
	正则表达式std::regex
		恶心的C正则(regex.h)和boost正则成为历史	
	编译期断言static_assert
		static_assert是用于涉及模板的assert，编译期就能发现不满足的情况，无需等到运行时出现core
		如下最后一个被注掉的static_assert如果放开，则无法通过编译。	
		template<class T> class C {  
			T data1_;  
			int data2_;  
		public:  
			C(T data1, int data2):data1_(data1), data2_(data2) {  
				/*if the condition is not satisfiedm, would be errored by compiler in compling*/  
				//static_assert(sizeof(T) > 4, "sizeof(T) is not larger than 4");  
				static_assert(sizeof(T) >= 4, "sizeof(T) is not larger than 4");  
				//static_assert(data2_ >= 10, "could not use static_assert here! condition must could be calced in compling!");  
			}  
		};  
		  
		TEST(test_static_assert, test) {  
			C<double> c(1.1, 1);  
		}  
	hash正式进入stl
		unordered_map、unordered_set、unordered_multimap、unordered_multiset。extstl扩展方式的使用hash成为历史。
	default关键字生成默认构造函数和析构函数
		default的默认构造方式可生成：默认无参数的构造函数、拷贝构造函数、赋值构造函数
		析构函数同样可以由default默认构造	
	delete关键字禁止拷贝构造、禁止赋值构造、禁止自定义参数的构造函数
		注意析构函数不可由delete修饰
		c++11以前的方式，是把需要禁止的构造函数，放在private里使外部无法调用；
		c++11风格的禁止构造的noncopyable基类实现如下，禁止了拷贝构造和赋值构造：
	委托构造函数
		一个构造函数，使用自己的参数，传递给其他构造函数去构造，作为自己的构造函数实现，
		如下例，后面两个构造函数，均传递参数，委托给第一个构造函数去实现
		[cpp] view plain copy
		<span style="font-size:10px;">struct A {  
				bool a_;  
				char b_;  
				int c_;  
				float d_;  
				double e_;  
				A(bool a, char b, int c, float d, double e): a_(a), b_(b), c_(c), d_(d), e_(e) {}  
				//construct reuse  
				A (int c): A(true, 'b', c, 1.1, 1000.1) {}  
				A (double e): A (false, 'a', 0, 0.1, e) {}  
			};  
		  
			A o1(10);  
			LOG(INFO) << "a: " << o1.a_ << ", b: " << o1.b_ << ", c: " << o1.c_ << ", d: " << o1.d_ << ", e: " << o1.e_;  
			A o2(5.5);  
			LOG(INFO) << "a: " << o2.a_ << ", b: " << o2.b_ << ", c: " << o2.c_ << ", d: " << o2.d_ << ", e: " << o2.e_;</span>  	
			
		移动构造函数：
			属于c++11的右值引用的衍生效果之一，首先描述右值引用std::move
			std::move主要能解决的拷贝性能问题
			类似于python的深拷贝和浅拷贝, python中的对象赋值和copy.copy都是浅拷贝, 赋值的都是对象的引用, copy.deepcopy则是深拷贝
			首先插一段python代码帮助理解深浅拷贝，建议用pdb跟一下代码感受更加深刻：
			[python] view plain copy
			<span style="font-size:10px;">import copy                                                                                  
			import json                                                                                  																																																				 
			a = [1, 2, 3, 4, 5, [99, 98]]                                                                
			#b全都是a的引用                                                                              
			b = a                                                                                        
			#c的非子对象都是a的复制构造, 但子对象还是引用                                                
			c = copy.copy(a)                                                                             
			#d全都是a的复制构造   
		std::move
		
			直接定位到实际应用上(程序中尽量不要出现"int &&a = 1"这样的东西，炫技容易搞出错误)
			c++11的std::move, 解决的问题是一个复制效率的问题:：
			对临时变量(如函数中的参数)的复制，通过更改对象的所有者(move)，实现免内存搬迁或拷贝(去除深拷贝)，
			提高"复制"效率(其实不是复制，仅是更改了对象的所有者。
			例一：改变引用持有者(减少复制成本，移交引用权力给有用的变量，同时免除不再有用变量对引用的持有权)
			[cpp] view plain copy
			<span style="font-size:10px;">    std::string a = "123";    //或std::string &&a = "123";显示的标识a是全局字符串"123"的右值引用  
			LOG(INFO) << "at first, std::string a is: " << a;   //打印123  

			/*右值"123", 它的所有者将从原先的左值(变量std::string a), 转移到新的左值(std::vector v) 
			*所以, 使用std::move时一定保证, 以前的左值不再真需要了. 典型使用场合就是: (构造)函数的参数, 避免了再复制*/  
			v.push_back(std::move(a));  
			LOG(INFO) << "after std::move(a), now std::string a is: " << a; //打印空</span> 
			最后的glog将无法打印出a最开始的拷贝构造获取的值"123"，因为全局字符串"123"的所有者，已经从最开始的变量a，转移到了v
			
			这在日常场合也是需要的，用途为：
				1、减少内存复制成本
				2、将不再需要的变量，取消它对原先持有变量(内存)的持有(修改)权限
				
			class test {  
			public:  
				std::vector<std::string> t_;  
				test(std::vector<std::string> &tmp) {  
					for (auto& i: tmp) {  
						//not copy rvalue to t_, only add rvalue reference to t_ and update rvalue's lifecycle  
						t_.push_back(std::move(i));  
					}  
				}  
			};  
		  
			/*起初, 右值("123", "456", "789", "012", "345")都归属于左值temp*/  
			std::vector<std::string> temp = {"123", "456", "789", "012", "345"};  
			LOG(INFO) << "before move to object ot, t's size is: " << temp.size();  
			for (auto& i: temp) {  
				LOG(INFO) << " OLD LVALUE(object temp) element: " << i;  
			}  
		  
			/*由类test的构造函数, 更改右值的所有者为类test的对象ot*/  
			test ot(temp);  
			LOG(INFO) << "after move elements of temp to object ot, now ot's size is: " << ot.t_.size();  
			for (auto& i: temp) {  
				LOG(INFO) << " OLD LVALUE(object temp) element: " << i;  //这个地方 应该不能正常打印，对象已经被移动到ot中。
			}  
			for (auto& i: ot.t_) {  
				LOG(INFO) << " NEW LVALUE(object ot) element: " << i;  
			}
			移动构造函数，最大的用途避免同一份内存数据的不必要的变成两份甚至多份、过程中的变量传递导致的内存复制，另外解除了栈变量对内存的引用；

		override和final
			作用于虚函数，更多的作用是：显式的标识是否应该多态继承或不应该
			1、override：子类用override修饰其虚函数，表示要多态继承基类的虚函数。不可以修饰非虚函数
			举一个rocksdb的merge运算符重载的例子：
			2、final：基类用final修饰其虚函数，意外其子类不可以多态继承该虚函数

		lambda、bind、function：
			函数式编程是c++11重要亮点之一
			4.1、直接lambda表达式
			完全如同python
			[cpp] view plain copy
			int a = 1, b = 2;  
			auto multi = [](int a, int b){  
				b = a + a + a;  
				return a + b;  
			};  		  
			LOG(INFO) << "by lambda: " << multi(a, b);  
			 函数multi
			4.2、c++11风格的函数指针std::function
			& std::bind
			[cpp] view plain copy
			int func1 (int a, int b) {  
				b = a + a + a;  
				return a + b;  
			}  			  
			auto a = 1, b = 2;  
			std::function<int (int, int)> modify_add0(func1);  
				   LOG(INFO) << "directly assign function: " << modify_add0(a, b);  
			 通过指定返回值、参数列表、绑定的函数和函数名，定义一个函数(指针)modify_add0
			绑定的函数，可以是普通函数，也可以是类成员函数，同时指定：
			[cpp] view plain copy
			class ca {  
			public:  
				bool func(int a) {  
					LOG(INFO) << "aaa: " << a;  
				}  
			};  			  
			ca o;  
			std::function<bool (int)> f = std::bind(&ca::func, o, std::placeholders::_1);  
			f(1);  
			 原先只有在boost出现且极为受限的函数占位符，也加入到了标准库，即std::placeholders，传递自定义参数
			绑定类成员函数时，需要配合使用std:bind。
			bind和placeholders，同样可以用于普通函数：
			[cpp] view plain copy
			int func1 (int a, int b) {  
				b = a + a + a;  
				return a + b;  
			}  			  
			auto a = 1, b = 2;  
			auto auto1 = std::bind(func1, std::placeholders::_1, std::placeholders::_2);  
			LOG(INFO) << "directly run auto: " << auto1(a, b);  
			 auto可以自动识别标准类型的变量的类型，同样可以用于std:;function：
			[cpp] view plain copy
			int func1 (int a, int b) {  
				b = a + a + a;  
				return a + b;  
			}  			  
			auto a = 1, b = 2;  
			auto auto1 = std::bind(func1, std::placeholders::_1, std::placeholders::_2);  
			LOG(INFO) << "directly run auto: " << auto1(a, b);  
			 std:;function作为函数指针，同样可以作为参数传递并执行：
			[cpp] view plain copy
			int func1 (int a, int b) {  
				b = a + a + a;  
				return a + b;  
			}  			  
			int func3 (auto f) {  
				return f(1, 2);  
			}  			  
			auto a = 1, b = 2;  
			auto auto1 = std::bind(func1, std::placeholders::_1, std::placeholders::_2);  
			LOG(INFO) << "run auto in function: " << func3(auto1);  
			 bind内不仅不再有boost占位符实现的1st、2nd的个数限制，还可以传递常量，并可以指定参数的顺序：
			[cpp] view plain copy
			int func2 (int a, double b, std::string c) {  
				b = a + a + a;  
				return int(a + b);  
			}  
			  
			/*std::function内的定义了该function调用时的顺序, 也是_1、_2、..._n的顺序, bind内要整理符合绑定的函数参数顺序*/  
			std::function<int (std::string, int)> modify_add2 = std::bind(func2, std::placeholders::_2, 2.0, std::placeholders::_1);  
			LOG(INFO) << "by bind with partly arg: " << modify_add2("aaa", 1);  
			 modify_add2函数执行时，第一个参数"aaa"第二个参数1，貌似和绑定的函数func2的顺序不符，就是因为bind内指定了占位符标识，占位符2作为第一个参数，常量2.0作为第二个参数，占位符1作为第三个参数，即1、2.0、"aaa"
			更广泛的用法，直接定义函数体：
			[cpp] view plain copy
			std::function<int ()> modify_add3 = std::function<int ()>([=, &b]{  
				b = a + a + a;  
				return a + b;  
			});  
			LOG(INFO) << "directly in-function: " << modify_add3();  
			这个做法是后面描述的std::thread的典型适配方法，让static void thread_func(void *arg) {......}作为线程执行函数体的作法成为历史！

		动态指针
			这也是c++11一个重要亮点
			如同函数式编程，动态指针同样大量移植了原先boost里的东西
			5.1、unique_ptr
			功能基本对应boost的scoped_ptr，或之前stl的auto_ptr，生命周期随构造者，reset自动析构再重新构造，get判断是否有效、支持放在容器内；
			真正意义智能指针。
			不论是临时变量指针、类成员指针变量.....90%的指针都应该用这个

			5.2、shared_ptr/weak_ptr
			功能对于boost的shared_ptr，可以有多个持有者的共享指针，即所谓引用计数型指针，直到最后一个持有者delete释放时，其指向的资源才会真正被释放
			典型应用案例：如对同一个全局无锁队列对象由shared_ptr封装，多线程的多个持有者均持有对其的引用。直到全部线程都释放掉对其的引用时，该无锁队列对象才会被最终销毁。
			也就是shared_ptr适合用于管理“全局动态资源”
			5.3 shared_arrary
			5.4 scoped_arrary
			
		auto ptr
				
		http://cpprocks.com/c11-compiler-support-shootout-visual-studio-gcc-clang-intel/	
				
	
	
			



ref:https://www.cnblogs.com/heyonggang/p/3246631.html
		https://blog.csdn.net/zcsylj/article/details/7857009
		https://www.cnblogs.com/CnZyy/p/3317999.html
		https://blog.csdn.net/qiuyumin430/article/details/79534150
		https://www.cnblogs.com/wangbin/p/7494427.html
	