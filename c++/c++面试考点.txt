1.C++中类与结构的唯一区别是：类（class）定义中默认情况下的成员是private的，而结构（struct）定义中默认情况下的成员是public的。
2. ::叫作用域区分符，指明一个函数属于哪个类或一个数据属于哪个类。::可以不跟类名，表示全局数据或全局函数（即非成员函数）。
3.类名加载成员函数名之前而不是加在函数的返回类型前。
	错误：Tdate::void Set(int m , int d , int y) {}
	正确： void Tdate::Set(int m , int d , int y) {}
4.一个类对象所占据的内存空间由它的数据成员所占据的空间总和所决定。类的成员函数不占据对象的内存空间。
5.类的成员函数可以访问该类的private成员。
6.类作用域是指类定义和相应的成员函数定义范围。在该范围内，一个类的成员函数对同一类的数据成员具有无限制的访问权。
7.#include <filename.h> 和#include “filename.h” 有什么区别？
	对于#include <filename.h> ，编译器从标准库路径开始搜索filename.h
	对于#include “filename.h”，编译器从用户的工作路径开始搜索filename.h
8.
	int a = 1 , b = 0;   // #define MAX(A,B) A>B?A:B;
	MAX(a++ , b);    //a被增值2次  
	MAX(a++ , b + 10); //a被增值1次 
	
9.类定义是不分配空间和初始化的。类是一个抽象的概念，并不是一个实体，并不含有属性值，而只有对象才占有一定的空间，含有明确的属性值。
10. 按成员在类定义中的声明顺序进行构造，而不是按构造函数说明中冒号后面的顺序。
	运行如下代码：
	复制代码
	class A
	{
	public:
	    A(int j):age(j) , num(age + 1)
	protected:
	    int num;
	    int age;
	};

	void mian()
	{
	    A sa(15);
	}
	复制代码
	代码运行结果：num=“随机值 ”， age= 15
	由于按成员在类定义中的声明顺序进行构造，而不是按构造函数说明中冒号后面的顺序，所以num成员被赋的是一个随机值，并不是想赋的16，因为这个时候，成员age还没有被赋值，age的内存空间中是一个随机值。
	
11.如果 const 出现在 * 左边，则指针指向的内容为常量；如果 const 出现在 * 右边，则指针自身为常量；如果 const 出现在 * 两边，则两者都为常量。
	const 的意思可以理解为"只读"。  
	
12.C++一维数组和指针的关系总结
	对于数组int a[10]; a表示数组的第一个元素的地址，即&a[0];
	如果使指针p，指向数组的首元素，可以进行操作：int * p=a; 或者int *p=&a[0];
	那么p++，是指向数组中的先一个元素，即a[1];
	　　此时*p则是a[1]中所放的值。
	　　此时，a[i]=p[i]=*(a+i)=*(p+i)
	关于*p++，由于++和*的优先级相同，结合方向是自右而左，因此它等价于*(p++)。作用是：先得到p指向的变量的值（即*p），然后再使指向p的值加1.
	*p++等价于*(p++);而*(++p)表示先使p+1,再取*p。	也要注意静态二维数组空间的连续性，如果分别new出来的一位数组则不连续。
	
13.在VC中，sizeof有着许多的用法，而且很容易引起一些错误。下面根据sizeof后面的参数对sizeof的用法做个总结。
	A.参数为数据类型或者为一般变量：
	例如sizeof(int),sizeof(long)等等。
	这种情况要注意的是不同系统系统或者不同编译器得到的结果可能是不同的。
	例如int类型在16位系统中占2个字节，在32位系统中占4个字节。
	B.参数为数组或指针：
	int a[50]; //sizeof(a)=4*50=200;求数组所占的空间大小
	int *a=new int[50];// sizeof(a)=4; a为一个指针，sizeof(a)是求指针的大小,在32位系统中，当然是占4个字节。
	C.参数为结构或类：
	Sizeof应用在类和结构的处理情况是相同的，需要考虑字节对齐(参加另一篇文章：http://www.cnblogs.com/heyonggang/archive/2012/12/11/2812304.html)。另外有几点需要注意：
	第一、结构或者类中的静态成员不对结构或者类的大小产生影响，因为静态变量的存储位置与结构或者类的实例地址无关。
	第二、没有成员变量的结构或类(非虚)的大小为1，因为必须保证结构或类的每一个实例在内存中都有唯一的地址。
	第三、包含虚函数的类或者虚继承的类，需要算上虚表指针的占的4个字节。
	下面举例说明：
	Class Test{int a;static double c};//sizeof(Test)=4
	Test *s;//sizeof(s)=4,s为一个指针。
	Class test1{ };//sizeof(test1)=1;
	Class test2{ virtual void print(){}};//sizeof(test2)=4;	

14.运算符new分配堆内存，如果成功，则返回指向该内存的空间，如果失败，则返回NULL。所以每次使用运算符new动态分配内存时，都应测试new的返回指针值，以防分配失败。
	注意反复new和free堆里面的内存空间，会产生内存碎片影响系统性能，这种情况应该考虑内存池。

15.如果你的类需要析构函数来析构资源，则它也需要一个拷贝构造函数（如果成员变量包含指针）。
	由于C++提供的默认拷贝构造函数只是对对象进行浅拷贝复制。如果对象的数据成员包括指向堆空间的指针，就不能使用这种拷贝方式，此时必须自定义拷贝构造函数，为创建的对象分配堆空间。
	
16.类成员函数的重载、覆盖和隐藏区别？
    答案：
    a.成员函数被重载的特征：
    （1）相同的范围（在同一个类中）；（2）函数名字相同；（3）参数不同；（4）virtual 关键字可有可无。
    b.覆盖是指派生类函数覆盖基类函数，特征是：
    （1）不同的范围（分别位于派生类与基类）；（2）函数名字相同；（3）参数相同；（4）基类函数必须有virtual 关键字。
    c.“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：
    （1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。
    （2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）
17.《C++程序设计教程》P352
	在例子中并没有声明派生类GraduateStudent的构造函数，根据类的实现机制，派生类对象创建时，将执行其默认的构造函数。
	该默认构造函数会先调用基类的默认构造函数，而基类没有默认构造函数，但正好匹配默认参数的构造函数。

18.在运行时，能根据其类型确认调用哪个函数的能力，称为多态性，或称迟后联编，或滞后联编。编译时就能确定哪个重载函数被调用的，称为先期联编。
	多态性可可以简单的概括为“一个借口，多种方法”，在程序运行的过程中才决定调用的函数。
	虚函数就是允许被其子类重新定义的成员函数。而子类重新定义父类虚函数的做法，称为“覆盖”或“重写”。
	覆盖是指子类重新定义父类的虚函数的做法。
	重载是指允许存在多个同名函数，而这些函数的参数表不同。
	为了指明某个成员函数具有多态性，用关键字virtual来标志其为虚函数。
	如果虚函数在基类与子类中出现的仅仅是名字的相同，而参数类型不同，或返回类型不同，即使写上了virtual关键字，则也不进行迟后联编。
	
19.一个类中将所有的成员函数都尽可能地设置为虚函数总是有益的。它除了会增加一些资源开销，没有其它坏处。
	设置虚函数，需注意下列事项：
	只有类的成员函数才能说明为虚函数。这是因为虚函数仅适用于有继承关系的类对象，所以普通函数不能说明为虚函数。
	静态成员函数不能是虚函数，因为静态成员函数不受限于某个对象。
	内联函数不能是虚函数，因为内联函数是不能在运行中动态确定其位置的。即使虚函数在类的内部定义，编译时，仍将其看作非内联的。
	构造函数不能是虚函数，因为构造时，对象还是一片未定型的空间。只有在构造完成后，对象才能成为一个类的名副其实的实例。
	析构函数可以是虚函数，而且通常声明为虚函数。

20. stl
	向量(vector)   连续存储的元素<vector>
	列表(list)     由节点组成的双向链表，每个结点包含着一个元素<list>
	双队列(deque)  连续存储的指向不同元素的指针所组成的数组<deque>
	集合(set)      由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种作用于元素对的谓词排列，没有两个不同的元素能够拥有相同的次序 <set>
	多重集合(multiset) 允许存在两个次序相等的元素的集合 <set>  multiset，与set不同之处就是它允许有重复的值,key 是不用的，但是key是set自己管理的。
	栈(stack)          后进先出的值的排列 <stack>
	队列(queue)        先进先出的执的排列 <queue>
	优先队列(priority_queue) 元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列 <queue>
	映射(map)                由{键，值}对组成的集合，也是以红黑平衡二叉树实现的，以某种作用于键对上的谓词排列 <map>
	多重映射(multimap)       允许键对有相等的次序的映射 <map>
	multiset与set的不同之处就是key可以重复，以及erase（key）的时候会删除multiset里面所有的key并且返回删除的个数。
	
	<utility>是一个很小的头文件，它包括了贯穿使用在STL中的几个模板的声明，
	<iterator>中提供了迭代器使用的许多方法，而对于<memory>的描述则十分的困难，它以不同寻常的方式为容器中的元素分配存储空间，同时也为某些算法执行期间产生的临时对象提供机制,
	<memory>中的主要部分是模板类allocator，它负责产生所有容器中的默认分配器
	
	vector应该是从堆上分配内存，所有大小与元素个数无关
	sizeof(vector)取决于vector类的具体实现，STL是个完全开放的东西，谁都可以来实现vector类。
	通过查看STL源码可以看到vector有四个成员变量?
	_A ? allocator;?
	iterator ? _First, ? _Last, ? _End;?
	每个指针是4个字节，因此16字节。20字节的是不是添加了什么指针呢？


	deque和vector一样,采用线性表，与vector唯一不同的是，
	deque采用的分块的线性存储结构，每块大小一般为512字节，称为一个deque块，
	所有的deque块使用一个Map块进行管理，每个map数据项记录各个deque块的首地址，这样以来，
	deque块在头部和尾部都可已插入和删除元素，而不需要移动其它元素。使用push_back()方法在尾部插入元素，使用push_front()方法在首部插入元素，
	使用insert()方法在中间插入元素。一般来说，当考虑容器元素的内存分配策略和操作的性能时，deque相对vectore更有优势。
	
	erase
	list与vector 
    list与vector中的erase用法相同，它们的 erase 函数会返回指向下一个元素的迭代器，因此在遍历时，只需要 it = c.erase(it); 即可。
  map与set
    map与set中的erase用法相同，它们的 erase 函数返回值是 void，调用 erase 之后，当前迭代器会失效，无法再用于获取下一个迭代器。因此需要 erase 之前就获取指向下一个元素的迭代器。
    
    
  static
  
  1.先来介绍它的第一条也是最重要的一条：隐藏
  2.static的第二个作用是保持变量内容的持久 （可以视为隐藏的全局变量）
  3.static的第三个作用是默认初始化为0
  4.static的第四个作用：C++中的类成员声明static
  在类中声明static变量或者函数时，初始化时使用作用域运算符来标明它所属类，因此，静态数据成员是类的成员，而不是对象的成员，这样就出现以下作用：
	(1)类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致 了它仅能访问类的静态数据和静态成员函数。//不能访问非静态数据和成员。
	(2)不能将静态成员函数定义为虚函数。
	(3)由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊 ，变量地址是指向其数据类型的指针 ，函数地址类型是一个“nonmember函数指针”。
	(4)由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就 产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C++和C-based X W indow系统结合，同时也成功的应用于线程函数身上。 （这条没遇见过）  
	(5)static并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问 时间，节省了子类的内存空间。      
	(6)静态数据成员在<定义或说明>时前面加关键字static。      
	(7)静态数据成员是静态存储的，所以必须对它进行初始化。 （程序员手动初始化，否则编译时一般不会报错，但是在Link时会报错误） 
	(8)静态成员初始化与一般数据成员初始化不同:
	初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；
	初始化时不加该成员的访问权限控制符private，public等；        
	初始化时使用作用域运算符来标明它所属类；
	           所以我们得出静态数据成员初始化的格式：
	<数据类型><类名>::<静态数据成员名>=<值>

  (9)为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。
    
   虚表
	    虚函数的实现是使用续表
	    继承至虚函数 子类覆盖虚函数，其实是在续表内的覆盖
	    普通同名函数，其实是对子类函数，进行重命名。
	    多继承的虚函数，类定义了相同的虚函数，则全部覆盖。
	 
	 struct &union
	 		struct和union都是由多个不同的数据类型成员组成, 但在任何同一时刻, union中只存放了一个被选中的成员; 而struct的所有成员都存在。
	 		在struct中，各成员都占有自己的内存空间，它们是同时存在的,一个struct变量的总长度等于所有成员长度之和，
	 		遵从字节对其原则; 在Union中，所有成员不能同时占用它的内存空间，它们不能同时存在 , Union变量的长度等于最长的成员的长度。
	 
	    对于union的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了,所以，共同体变量中起作用的成员是最后一次存放的成员; 
	    而对于struct的不同成员赋值是互不影响的。
	    
	    union 很想 enum 只不过enum的成员都是整数类型。 
	    
	  有了malloc/free为什么还要new/delete？
	　　malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。
	　　对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。
			由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。
			因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。
			
			
	内存管理：
		
		堆 heap ：
			由new分配的内存块，其释放编译器不去管，由我们程序自己控制（一个new对应一个delete）。如果程序员没有释放掉，在程序结束时OS会自动回收。涉及的问题：“缓冲区溢出”、“内存泄露”

		栈 stack ：
			是那些编译器在需要时分配，在不需要时自动清除的存储区。存放局部变量、函数参数。
			存放在栈中的数据只在当前函数及下一层函数中有效，一旦函数返回了，这些数据也就自动释放了。

		全局/静态存储区 （.bss段和.data段） ：
			全局和静态变量被分配到同一块内存中。在C语言中，未初始化的放在.bss段中，初始化的放在.data段中；在C++里则不区分了。

		常量存储区 （.rodata段） ：
			存放常量，不允许修改（通过非正当手段也可以修改）

		代码区 （.text段）：
			存放代码（如函数），不允许修改（类似常量存储区），但可以执行（不同于常量存储区）
					
		根据c/c++对象生命周期不同，c/c++的内存模型有三种不同的内存区域，即
			自由存储区：局部非静态变量的存储区域，即平常所说的栈
			动态区：用operator new ，malloc分配的内存，即平常所说的堆
			静态区：全局变量 静态变量 字符串常量存在位置

	
	c11
		auto
			C++11中引入auto第一种作用是为了自动类型推导
			auto的自动类型推导，用于从初始化表达式中推断出变量的数据类型。通过auto的自动类型推导，可以大大简化我们的编程工作
			auto实际上实在编译时对变量进行了类型推导，所以不会对程序的运行效率造成不良影响
			另外，似乎auto并不会影响编译速度，因为编译时本来也要右侧推导然后判断与左侧是否匹配。	
				auto不光有以上的应用，它在模板中也是大显身手，比如下例这个加工产品的例子中，如果不使用auto就必须声明Product这一模板参数：
				template <typename Product, typename Creator>  
				void processProduct(const Creator& creator) {  
				    Product* val = creator.makeObject();  
				    // do somthing with val  
				}         
				        . 
				如果使用auto，则可以这样写：
				template <typename Creator>  
				void processProduct(const Creator& creator) {  
				    auto val = creator.makeObject();  
				    // do somthing with val  
				}
				
		decltype
			decltype实际上有点像auto的反函数，auto可以让你声明一个变量，而decltype则可以从一个变量或表达式中得到类型，有实例如下：
			int x = 3;  
			decltype(x) y = x;  //提供一种通过变量去定义变量，的机制。
			有人会问，decltype的实用之处在哪里呢，我们接着上边的例子继续说下去，如果上文中的加工产品的例子中我们想把产品作为返回值该怎么办呢？我们可以这样写：		 
			
		nullptr
			nullptr是为了解决原来C++中NULL的二义性问题而引进的一种新的类型，因为NULL实际上代表的是0，
			
		for
			在C++中for循环可以使用类似java的简化的for循环，可以用于遍历数组，容器，string以及由begin和end函数定义的序列（即有Iterator），示例代码如下：
			map<string, int> m{{"a", 1}, {"b", 2}, {"c", 3}};  
			for (auto p : m){  
			    cout<<p.first<<" : "<<p.second<<endl;  
			}
			
		Lambda表达式
			lambda表达式类似Javascript中的闭包，它可以用于创建并定义匿名的函数对象，以简化编程工作。Lambda的语法如下：

			[函数对象参数]（操作符重载函数参数）->返回值类型{函数体}
			vector<int> iv{5, 4, 3, 2, 1};  
			int a = 2, b = 1;  
			for_each(iv.begin(), iv.end(), [b](int &x){cout<<(x + b)<<endl;}); // (1) 
			for_each(iv.begin(), iv.end(), [=](int &x){x *= (a + b);});     // (2) 
			for_each(iv.begin(), iv.end(), [=](int &x)->int{return x * (a + b);});// (3) 
			[]内的参数指的是Lambda表达式可以取得的全局变量。(1)函数中的b就是指函数可以得到在Lambda表达式外的全局变量，如果在[]中传入=的话，即是可以取得所有的外部变量，如（2）和（3）Lambda表达式
			()内的参数是每次调用函数时传入的参数。
			->后加上的是Lambda表达式返回值的类型，如（3）中返回了一个int类型的变量
			
		变长参数的模板
			我们在C++中都用过pair，pair可以使用make_pair构造，构造一个包含两种不同类型的数据的容器。比如，如下代码：
			auto p = make_pair(1, "C++ 11"); 
			由于在C++11中引入了变长参数模板，所以发明了新的数据类型：tuple，tuple是一个N元组，可以传入1个， 2个甚至多个不同类型的数据
			auto t1 = make_tuple(1, 2.0, "C++ 11");  
			auto t2 = make_tuple(1, 2.0, "C++ 11", {1, 0, 2}); 
			这样就避免了从前的pair中嵌套pair的丑陋做法，使得代码更加整洁

			另一个经常见到的例子是Print函数，在C语言中printf可以传入多个参数，在C++11中，我们可以用变长参数模板实现更简洁的Print

			template<typename head, typename... tail>  
			void Print(Head head, typename... tail) {  
			    cout<< head <<endl;  
			    Print(tail...);  
			} 
			Print中可以传入多个不同种类的参数，如下：
			Print(1, 1.0, "C++11"); 
			
		更加优雅的初始化方法
			在引入C++11之前，只有数组能使用初始化列表，其他容器想要使用初始化列表，只能用以下方法：
			int arr[3] = {1, 2, 3}  
			vector<int> v(arr, arr + 3); 
			在C++11中，我们可以使用以下语法来进行替换：
			int arr[3]{1, 2, 3};  
			vector<int> iv{1, 2, 3};  
			map<int, string>{{1, "a"}, {2, "b"}};  
			string str{"Hello World"};
		
		Lambda函数
			C++14的泛型Lambda使编写如下语句成为可能：
			auto lambda = [](auto x, auto y) {return x + y;};
			而另一方面，C++11要求Lambda参数使用具体的类型声明，比如：
			auto lambda = [](int x, int y) {return x + y;};
			此外，新标准中的std::move函数可用于捕获Lambda表达式中的变量，这是通过移动对象而非复制或引用对象实现的：
			std::unique_ptr ptr(new int(10));
			auto lambda = [value = std::move(ptr)] {return *value;};
			
		constexpr
			在C++11中，使用constexpr声明的函数可以在编译时执行，生成一个值，用在需要常量表达式的地方，比如作为初始化模板的整形参数。
			C++11的constexpr函数只能包含一个表达式，C++14放松了这些限制，支持诸如if 和switch等条件语句，支持循环，其中包括基于区间（range）的for 循环。
		
		类型推导
			C++11仅支持Lambda函数的类型推导，C++14对其加以扩展，支持所有函数的返回类型推导：
			auto DeducedReturnTypeFunction();

			因为C++14是强类型语言，有些限制需要考虑：
				如果一个函数的实现中有多个返回语句，这些语句一定要推导出同样的类型。
				返回类型推导可以用在前向声明中，但是在使用它们之前，翻译单元中必须能够得到函数定义。
				返回类型推导可以用在递归函数中，但是递归调用必须以至少一个返回语句作为先导，以便编译器推导出返回类型。
				C++14带来的另一个类型推导方面的改进是decltype(auto)语法，它支持使用与auto同样的机制计算给定表达式的类型。
					auto和 decltype在C++11中就已经出现了，但是它们在推导类型时使用了不同的机制，这可能会产生不同的结果。
					
				C++14中的其他改变包括可以声明变量模板，支持使用0b或0B前缀来声明二进制字面常量。InfoQ已经介绍过C++14中可能破坏C++11程序的其他小型修改。
				主流C++编译器对新语言特性的支持正在有条不紊地开发：Clang“完全实现了当前草案的所有内容”；GCC和Visual Studio也对C++14的新特性提供了一些支持。		     
	 
    		std=c++0x
    		
    多线程
			这是第一次，C++11将包含一种内存模型和对应的多线程库，这意味着你将可以编写符合标准的多线程代码。
			新标准将提供所有的通用线程方法，比如线程、线程局部存储和原子操作。
			它也提供了一系列有趣的特性：futures和promises。futures和promises的主要思想是，你可以编写代码表示，“这个对象，一个future代码还没计算完的结果”，它将可以在后台计算结果。
			当这个值需要的时候，你向future发请求，假如这个值准备好了，那就可以得到它，要不然继续等待。
			
		auto ptr
				
		http://cpprocks.com/c11-compiler-support-shootout-visual-studio-gcc-clang-intel/	
				
	
	
			



ref:https://www.cnblogs.com/heyonggang/p/3246631.html
		https://blog.csdn.net/zcsylj/article/details/7857009
		https://www.cnblogs.com/CnZyy/p/3317999.html
		https://blog.csdn.net/qiuyumin430/article/details/79534150
	